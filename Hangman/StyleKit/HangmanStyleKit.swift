//
//  HangmanStyleKit.swift
//  Hangman
//
//  Created on 14.02.20.
//  Copyright Â© 2020 (null). All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class HangmanStyleKit : NSObject {

    //// Drawing Methods

    @objc dynamic public class func drawHangman(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 70, height: 70), resizing: ResizingBehavior = .aspectFit, attempts: CGFloat = -28) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 70, height: 70), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 70, y: resizedFrame.height / 70)



        //// Variable Declarations
        let firstVisible = attempts > 0
        let secondVisible = attempts > 1
        let thirdVisible = attempts > 2
        let forthVisible = attempts > 3
        let fifthVisible = attempts > 4
        let sixthVisible = attempts > 5
        let seventhVisible = attempts > 6
        let eighthVisible = attempts > 7
        let ninthVisible = attempts > 8
        let tenthVisible = attempts > 9
        let eleventhVisible = attempts > 10

        //// Group
        if (firstVisible) {
            //// bottom Drawing
            let bottomPath = UIBezierPath(rect: CGRect(x: 5, y: 62, width: 59, height: 2))
            UIColor.gray.setFill()
            bottomPath.fill()
        }


        if (secondVisible) {
            //// Rectangle 2 Drawing
            let rectangle2Path = UIBezierPath(rect: CGRect(x: 19, y: 7, width: 2, height: 57))
            UIColor.gray.setFill()
            rectangle2Path.fill()
        }


        if (thirdVisible) {
            //// Rectangle 3 Drawing
            let rectangle3Path = UIBezierPath(rect: CGRect(x: 19, y: 7, width: 25, height: 2))
            UIColor.gray.setFill()
            rectangle3Path.fill()
        }


        if (fifthVisible) {
            //// rope Drawing
            let ropePath = UIBezierPath(rect: CGRect(x: 41, y: 9, width: 1, height: 13))
            UIColor.gray.setFill()
            ropePath.fill()
        }


        if (forthVisible) {
            //// Strut Drawing
            context.saveGState()
            context.translateBy(x: 19, y: 22)
            context.rotate(by: -45 * CGFloat.pi/180)

            let strutPath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 21, height: 2))
            UIColor.gray.setFill()
            strutPath.fill()

            context.restoreGState()
        }


        if (seventhVisible) {
            //// Rectangle 5 Drawing
            let rectangle5Path = UIBezierPath(rect: CGRect(x: 41, y: 31, width: 1, height: 13))
            UIColor.gray.setFill()
            rectangle5Path.fill()
        }


        if (ninthVisible) {
            //// Rectangle 6 Drawing
            context.saveGState()
            context.translateBy(x: 41.5, y: 44)
            context.rotate(by: -45 * CGFloat.pi/180)

            let rectangle6Path = UIBezierPath(rect: CGRect(x: -0.5, y: 0, width: 1, height: 9))
            UIColor.gray.setFill()
            rectangle6Path.fill()

            context.restoreGState()
        }


        if (tenthVisible) {
            //// Rectangle 8 Drawing
            context.saveGState()
            context.translateBy(x: 41.5, y: 34)
            context.rotate(by: 45 * CGFloat.pi/180)

            let rectangle8Path = UIBezierPath(rect: CGRect(x: -0.5, y: 0, width: 1, height: 9))
            UIColor.gray.setFill()
            rectangle8Path.fill()

            context.restoreGState()
        }


        if (eleventhVisible) {
            //// Rectangle 9 Drawing
            context.saveGState()
            context.translateBy(x: 41.5, y: 34)
            context.rotate(by: -45 * CGFloat.pi/180)

            let rectangle9Path = UIBezierPath(rect: CGRect(x: -0.5, y: 0, width: 1, height: 9))
            UIColor.gray.setFill()
            rectangle9Path.fill()

            context.restoreGState()
        }


        if (sixthVisible) {
            //// Face
            //// Oval Drawing
            let ovalPath = UIBezierPath(ovalIn: CGRect(x: 36.5, y: 21.5, width: 10, height: 10))
            UIColor.gray.setStroke()
            ovalPath.lineWidth = 1
            ovalPath.stroke()


            //// Bezier Drawing
            let bezierPath = UIBezierPath()
            bezierPath.move(to: CGPoint(x: 39.2, y: 24.5))
            bezierPath.addCurve(to: CGPoint(x: 40, y: 25.3), controlPoint1: CGPoint(x: 39.2, y: 24.5), controlPoint2: CGPoint(x: 39.59, y: 24.89))
            bezierPath.addCurve(to: CGPoint(x: 40.77, y: 24.53), controlPoint1: CGPoint(x: 40.35, y: 24.95), controlPoint2: CGPoint(x: 40.68, y: 24.62))
            bezierPath.addCurve(to: CGPoint(x: 40.8, y: 24.5), controlPoint1: CGPoint(x: 40.79, y: 24.51), controlPoint2: CGPoint(x: 40.8, y: 24.5))
            bezierPath.addLine(to: CGPoint(x: 41, y: 24.7))
            bezierPath.addCurve(to: CGPoint(x: 40.2, y: 25.5), controlPoint1: CGPoint(x: 41, y: 24.7), controlPoint2: CGPoint(x: 40.61, y: 25.09))
            bezierPath.addCurve(to: CGPoint(x: 41, y: 26.3), controlPoint1: CGPoint(x: 40.61, y: 25.91), controlPoint2: CGPoint(x: 41, y: 26.3))
            bezierPath.addLine(to: CGPoint(x: 40.8, y: 26.5))
            bezierPath.addCurve(to: CGPoint(x: 40, y: 25.7), controlPoint1: CGPoint(x: 40.8, y: 26.5), controlPoint2: CGPoint(x: 40.41, y: 26.11))
            bezierPath.addCurve(to: CGPoint(x: 39.2, y: 26.5), controlPoint1: CGPoint(x: 39.59, y: 26.11), controlPoint2: CGPoint(x: 39.2, y: 26.5))
            bezierPath.addLine(to: CGPoint(x: 39, y: 26.3))
            bezierPath.addCurve(to: CGPoint(x: 39.8, y: 25.5), controlPoint1: CGPoint(x: 39, y: 26.3), controlPoint2: CGPoint(x: 39.39, y: 25.91))
            bezierPath.addCurve(to: CGPoint(x: 39, y: 24.7), controlPoint1: CGPoint(x: 39.39, y: 25.09), controlPoint2: CGPoint(x: 39, y: 24.7))
            bezierPath.addLine(to: CGPoint(x: 39.2, y: 24.5))
            bezierPath.close()
            UIColor.gray.setFill()
            bezierPath.fill()


            //// Bezier 2 Drawing
            let bezier2Path = UIBezierPath()
            bezier2Path.move(to: CGPoint(x: 42.21, y: 24.5))
            bezier2Path.addCurve(to: CGPoint(x: 43.04, y: 25.3), controlPoint1: CGPoint(x: 42.21, y: 24.5), controlPoint2: CGPoint(x: 42.61, y: 24.89))
            bezier2Path.addCurve(to: CGPoint(x: 43.83, y: 24.53), controlPoint1: CGPoint(x: 43.4, y: 24.95), controlPoint2: CGPoint(x: 43.74, y: 24.62))
            bezier2Path.addCurve(to: CGPoint(x: 43.86, y: 24.5), controlPoint1: CGPoint(x: 43.85, y: 24.51), controlPoint2: CGPoint(x: 43.86, y: 24.5))
            bezier2Path.addLine(to: CGPoint(x: 44.07, y: 24.7))
            bezier2Path.addCurve(to: CGPoint(x: 43.24, y: 25.5), controlPoint1: CGPoint(x: 44.07, y: 24.7), controlPoint2: CGPoint(x: 43.67, y: 25.09))
            bezier2Path.addCurve(to: CGPoint(x: 44.07, y: 26.3), controlPoint1: CGPoint(x: 43.67, y: 25.91), controlPoint2: CGPoint(x: 44.07, y: 26.3))
            bezier2Path.addLine(to: CGPoint(x: 43.86, y: 26.5))
            bezier2Path.addCurve(to: CGPoint(x: 43.04, y: 25.7), controlPoint1: CGPoint(x: 43.86, y: 26.5), controlPoint2: CGPoint(x: 43.46, y: 26.11))
            bezier2Path.addCurve(to: CGPoint(x: 42.21, y: 26.5), controlPoint1: CGPoint(x: 42.61, y: 26.11), controlPoint2: CGPoint(x: 42.21, y: 26.5))
            bezier2Path.addLine(to: CGPoint(x: 42, y: 26.3))
            bezier2Path.addCurve(to: CGPoint(x: 42.83, y: 25.5), controlPoint1: CGPoint(x: 42, y: 26.3), controlPoint2: CGPoint(x: 42.4, y: 25.91))
            bezier2Path.addCurve(to: CGPoint(x: 42, y: 24.7), controlPoint1: CGPoint(x: 42.4, y: 25.09), controlPoint2: CGPoint(x: 42, y: 24.7))
            bezier2Path.addLine(to: CGPoint(x: 42.21, y: 24.5))
            bezier2Path.close()
            UIColor.gray.setFill()
            bezier2Path.fill()


        }


        if (eighthVisible) {
            //// Bezier 4 Drawing
            let bezier4Path = UIBezierPath()
            bezier4Path.move(to: CGPoint(x: 42, y: 41))
            bezier4Path.addCurve(to: CGPoint(x: 42, y: 44.23), controlPoint1: CGPoint(x: 42, y: 41), controlPoint2: CGPoint(x: 42, y: 42.61))
            bezier4Path.addCurve(to: CGPoint(x: 35.49, y: 50.72), controlPoint1: CGPoint(x: 41.75, y: 44.48), controlPoint2: CGPoint(x: 35.49, y: 50.72))
            bezier4Path.addLine(to: CGPoint(x: 34.78, y: 50.01))
            bezier4Path.addCurve(to: CGPoint(x: 41, y: 43.79), controlPoint1: CGPoint(x: 34.78, y: 50.01), controlPoint2: CGPoint(x: 40.05, y: 44.74))
            bezier4Path.addCurve(to: CGPoint(x: 41, y: 41), controlPoint1: CGPoint(x: 41, y: 42.04), controlPoint2: CGPoint(x: 41, y: 41))
            bezier4Path.addLine(to: CGPoint(x: 42, y: 41))
            bezier4Path.addLine(to: CGPoint(x: 42, y: 41))
            bezier4Path.close()
            UIColor.gray.setFill()
            bezier4Path.fill()
        }
        
        context.restoreGState()

    }




    @objc(HangmanStyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
